from pwn import remote
import hashlib
import json
import math
import re

FROST_PRIME = int("1a66804d885939d7acf3a4b413c9a24547b876e706913adec9684cc4a63ab0dfd2e0fd79f683de06ad17774815dfc8375370eb3d0fb5dce0019bd0632e7663a41", 16)
GROUP_ORDER = FROST_PRIME - 1

FACTORS = [
    (2, 6),
    (3, 35),
    (5, 21),
    (7, 6),
    (137, 11),
    (191, 2),
    (331, 3),
    (3469, 2),
    (3613, 11),
    (3967, 6),
    (16561, 3),
]

def egcd(a, b):
    if b == 0:
        return a, 1, 0
    g, x, y = egcd(b, a % b)
    return g, y, x - (a // b) * y

def inv_mod(a, m):
    a %= m
    g, x, _ = egcd(a, m)
    if g != 1:
        raise ValueError("no inverse")
    return x % m

def sha_snowmark(msg):
    h = hashlib.sha512(msg.encode()).digest()
    return int.from_bytes(h, "big") % FROST_PRIME

def order_in_group(g):
    ord_ = GROUP_ORDER
    for q, e in FACTORS:
        for _ in range(e):
            if ord_ % q == 0 and pow(g, ord_ // q, FROST_PRIME) == 1:
                ord_ //= q
            else:
                break
    return ord_

class PohligHellmanFixedBase:
    def __init__(self, g):
        self.P = FROST_PRIME
        self.N = GROUP_ORDER
        self.g = g % self.P
        self.mods = []
        self.Ni = []
        self.invNi = []
        self.parts = []
        for q, e in FACTORS:
            self.mods.append(q ** e)
        for mod in self.mods:
            Ni = self.N // mod
            self.Ni.append(Ni)
            self.invNi.append(inv_mod(Ni, mod))
        for (q, e), mod in zip(FACTORS, self.mods):
            m = self.N // mod
            g0 = pow(self.g, m, self.P)
            q_pows = [1]
            for _ in range(e):
                q_pows.append(q_pows[-1] * q)
            g_steps = []
            inv_g_steps = []
            for k in range(e):
                gk = pow(g0, q_pows[k], self.P)
                g_steps.append(gk)
                inv_g_steps.append(pow(gk, self.P - 2, self.P))
            base = pow(g0, q_pows[e - 1], self.P)
            table = {}
            val = 1
            for j in range(q):
                table[val] = j
                val = (val * base) % self.P
            self.parts.append((q, e, mod, m, q_pows, g_steps, inv_g_steps, table))

    def dlog(self, h):
        h %= self.P
        residues = []
        for (q, e, mod, m, q_pows, g_steps, inv_g_steps, table) in self.parts:
            h0 = pow(h, m, self.P)
            x = 0
            inv_g_acc = 1
            for k in range(e):
                exp = q_pows[e - 1 - k]
                t = pow((h0 * inv_g_acc) % self.P, exp, self.P)
                d = table.get(t)
                if d is None:
                    raise ValueError("dlp fail")
                x += d * q_pows[k]
                if d:
                    inv_g_acc = (inv_g_acc * pow(inv_g_steps[k], d, self.P)) % self.P
            residues.append(x % mod)
        x = 0
        for r, mod, Ni, invNi in zip(residues, self.mods, self.Ni, self.invNi):
            x = (x + r * Ni * invNi) % self.N
        return x

def legendre_bit(a, p):
    return 1 if pow(a, (p - 1) // 2, p) == 1 else 0

def recover_shift_bsgs(p, observed_bits, t=40):
    N = p - 1
    m = math.isqrt(N) + 1
    need = m + t
    if len(observed_bits) < need:
        raise ValueError("not enough bits")
    mask = (1 << t) - 1
    table = {}
    block = 0
    for j in range(t):
        block = (block << 1) | observed_bits[j]
    table.setdefault(block, []).append(0)
    for i in range(1, m):
        block = ((block << 1) & mask) | observed_bits[i + t - 1]
        table.setdefault(block, []).append(i)
    for q in range(m + 1):
        start = (q * m) % N
        b = 0
        for j in range(t):
            idx = (start + j) % N
            b = (b << 1) | legendre_bit(idx + 1, p)
        if b in table:
            for i in table[b]:
                sigma = (q * m - i) % N
                ok = True
                for k in range(2000):
                    if observed_bits[k] != legendre_bit(((sigma + k) % N) + 1, p):
                        ok = False
                        break
                if ok:
                    return sigma
    raise ValueError("shift not found")

def pick_generator_msg():
    for i in range(1, 500):
        cand = f"msg{i}"
        g = sha_snowmark(cand)
        if g in (0, 1):
            continue
        if order_in_group(g) == GROUP_ORDER:
            return cand, g
    raise RuntimeError("generator msg not found")

def read_holly_prime(r):
    buf = b""
    for _ in range(50):
        line = r.recvline()
        if not line:
            break
        buf += line
        m = re.search(rb"holly_prime\s*=\s*(\d+)", buf)
        if m:
            return int(m.group(1))
    raise RuntimeError("holly_prime not found")

def main():
    host = input("HOST: ").strip()
    port_s = input("PORT: ").strip()
    port = int(port_s)

    msg, g = pick_generator_msg()
    ph = PohligHellmanFixedBase(g)

    r = remote(host, port)
    holly_prime = read_holly_prime(r)
    N = holly_prime - 1

    t = 40
    m_sqrt = math.isqrt(N) + 1
    need_bits = m_sqrt + t
    Q = (need_bits + 499) // 500

    observed = []
    for _ in range(Q):
        r.sendlineafter(b"> ", b"1")
        r.sendlineafter(b"Whisper your message: ", msg.encode())
        jline = r.recvline_contains(b"signature")
        sig = int(json.loads(jline.decode())["signature"])
        k = ph.dlog(sig)
        bits = bin(k)[2:].zfill(500)
        observed.extend(1 if c == "1" else 0 for c in bits)

    sigma = recover_shift_bsgs(holly_prime, observed, t=t)
    offset = (Q * 500) % N

    otp_len = 84 * 8
    otp_bits = []
    for i in range(otp_len):
        idx = (sigma + offset + i) % N
        otp_bits.append(legendre_bit(idx + 1, holly_prime))

    otp_int = int("".join(map(str, otp_bits)), 2)
    otp_str = bin(otp_int)[2:] or "0"

    r.sendlineafter(b"> ", b"2")
    r.sendlineafter(b"Reveal my snow-otp (in bits): ", otp_str.encode())
    out = r.recvline_contains(b"starshard").decode()
    print(out)
    r.close()

if __name__ == "__main__":
    main()
